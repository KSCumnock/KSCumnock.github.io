<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kerr & Smith Time Keeper Report</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .report-header {
            margin-bottom: 20px;
            padding: 20px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            position: relative;
        }
        .report-header h1 {
            font-size: 2em;
            margin-bottom: 10px;
            color: #333;
        }
        .report-header p {
            font-size: 1.1em;
            color: #555;
        }
        .date-picker {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }
        .date-picker input, .date-picker select {
            padding: 5px;
            font-size: 1em;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .employee-container {
            margin-bottom: 40px;
            padding: 20px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            page-break-inside: avoid;
        }
        .employee-header {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
        .employee-total-hours {
            margin-top: 25px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        .employee-total-hours h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 1.3em;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
        }
        .day-container {
            margin-bottom: 30px;
            transition: all 0.3s ease;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }
        .day-container:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
        }
        .day-header {
            padding: 12px 15px;
            background-color: #f8f9fa;
            border-radius: 8px 8px 0 0;
            border-left: 4px solid #04a9fd;
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
        }
        .timeline {
            display: flex;
            align-items: center;
            height: 20px;
            background-color: #333;
            border-radius: 10px;
            position: relative;
            margin: 15px;
            overflow: hidden;
        }
        .timeline-scale {
            display: flex;
            justify-content: space-between;
            margin: 5px 15px;
            font-size: 0.9em;
            color: #555;
        }
        .progress-bar {
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            width: 0;
            transition: width 0.8s ease-in-out;
        }
        .marker {
            position: absolute;
            top: 0;
            height: 100%;
            width: 1px;
            background-color: rgba(255, 255, 255, 0.5); /* Light gray line */
            z-index: 1;
        }
        .marker-label {
            position: absolute;
            top: -20px; /* Position above the timeline */
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8em;
            color: #555;
            white-space: nowrap;
        }
        .notes {
            margin: 15px;
            font-size: 0.9em;
            color: #555;
        }
        
        /* Hours breakdown styling */
        .hours-breakdown {
            background-color: white;
            border-radius: 8px;
          
            overflow: hidden;
            margin: 15px;
        }
        
        .hours-calculation {
            padding: 15px;
        }
        
        .calculation-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
            align-items: center;
        }
        
        .calculation-row:last-child {
            border-bottom: none;
        }
        
        .calculation-row.total {
            font-weight: bold;
            font-size: 1.1em;
            margin-top: 5px;
            padding-top: 10px;
            border-top: 2px solid #f0f0f0;
            color: #2e7d32;
        }
        
        .calculation-row .label {
            color: #555;
            flex: 1;
        }
        
        .value-container {
            text-align: right;
            display: flex;
            align-items: center;
        }
        
        .calculation-row .value {
            font-family: 'Courier New', monospace;
            padding: 3px 8px;
            border-radius: 3px;
            background-color: #f5f5f5;
            margin-right: 8px;
            min-width: 70px;
            text-align: center;
        }
        
        .calculation-row .decimal-value {
            color: #666;
            font-size: 0.9em;
        }
        
        .total .value {
            background-color: #e8f5e9;
            font-weight: bold;
        }
        
        .total .decimal-value {
            font-weight: bold;
            color: #2e7d32;
        }
        
        /* Live hours styling */
        .live-hours {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            background-color: #f5f5f5;
            border-bottom: 1px solid #e0e0e0;
            justify-content: space-between;
        }
        
        .live-status {
            display: flex;
            align-items: center;
        }
        
        .status-text {
            margin-right: 8px;
            font-weight: bold;
            color: #666;
        }
        
        .currently-working .status-text {
            color: #2e7d32;
        }
        
        .on-break .status-text {
            color: #ff8f00;
        }
        
        .live-time {
            display: flex;
            align-items: center;
        }
        
        .live-time-counter {
            margin: 0 8px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            background-color: #e0e0e0;
            padding: 3px 8px;
            border-radius: 3px;
        }
        
        .live-indicator {
            color: #f44336;
            font-size: 1.2em;
            animation: pulse 2s infinite;
        }
        
        .currently-working .live-indicator {
            color: #4CAF50;
        }
        
        .on-break .live-indicator {
            color: #ff9800;
        }
        
        /* Make summary stand out more */
        .employee-total-hours .hours-calculation {
            background-color: white;
            border-radius: 8px;
            padding: 10px 15px;
        }
        
        .employee-total-hours .calculation-row {
            padding: 10px 0;
        }
        
        .employee-total-hours .total {
            color: #1b5e20;
            font-size: 1.2em;
        }
        
        .employee-total-hours .total .value {
            background-color: #c8e6c9;
            padding: 5px 10px;
        }
        
        /* Colors for event types */
        .working { background-color: #4CAF50; }
        .break { background-color: #FFC107; }
        .lunch { background-color: #FF9800; }
        .clocked-out { background-color: #333; }
        
        /* Break violation indicators */
        .break-violation {
            position: absolute;
            top: 0;
            height: 100%;
            background-color: rgba(255, 0, 0, 0.5);
            z-index: 2;
        }
        
        /* Tooltip for break violations */
        .tooltip {
            position: absolute;
            top: -30px;
            background-color: #333;
            color: white;
            padding: 5px;
            border-radius: 3px;
            font-size: 0.8em;
            white-space: nowrap;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 10;
        }
        
        .break-violation:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }

        /* Grid card style for employee status */
        .employee-status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
            padding-bottom: 40px;
        }
        .employee-status-card {
            border: 1px solid #ddd;
            border-radius: 10px;
            padding: 15px;
            background-color: white;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease-in-out;
            cursor: pointer;
        }
        .employee-status-card:hover {
            transform: translateY(-5px);
        }
        .employee-status-card h3 {
            margin: 0 0 10px;
            font-size: 1.2em;
            color: #333;
        }
        .employee-status-card p {
            margin: 5px 0;
            font-size: 0.9em;
            color: #555;
        }
        /* Card colors based on status */
        .employee-status-grid .employee-status-card.clocked-out h3,
        .employee-status-grid .employee-status-card.clocked-out p {
            color: white !important;
        }

        .employee-status-grid .employee-status-card.clocked-in h3,
        .employee-status-grid .employee-status-card.clocked-in p {
            color: white !important;
        }

        .employee-status-grid .employee-status-card.on-break h3,
        .employee-status-grid .employee-status-card.on-break p {
            color: black !important;
        }

        .employee-status-grid .employee-status-card.on-lunch h3,
        .employee-status-grid .employee-status-card.on-lunch p {
            color: white !important;
        }

        /* Buttons */
        .action-buttons {
            margin-bottom: 20px;
        }
        .action-buttons button {
            padding: 10px 20px;
            font-size: 1em;
            border: none;
            border-radius: 5px;
            background-color: #04a9fd;
            color: white;
            cursor: pointer;
            margin-right: 10px;
            transition: background-color 0.2s ease-in-out;
        }
        .action-buttons button:hover {
            background-color: #0773f9;
        }
        
        /* Department filter */
        .filter-container {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
        }
        .filter-container label {
            margin-right: 10px;
            font-weight: bold;
        }
        .filter-container select {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        
        /* Legend for timeline colors */
        .timeline-legend {
            display: flex;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 5px;
            border-radius: 3px;
        }
        .legend-label {
            font-size: 0.9em;
        }
        .legend-color.working { background-color: #4CAF50; }
        .legend-color.break { background-color: #FFC107; }
        .legend-color.lunch { background-color: #FF9800; }
        .legend-color.clocked-out { background-color: #333; }
        .legend-color.violation { background-color: rgba(255, 0, 0, 0.5); }
    </style>
</head>
<body>
    <div class="report-header">
        <h1>Kerr & Smith Time Keeper</h1>
        <p>Date Range: <span id="dateRange">Loading...</span></p>
        <p>Total Employees: <span id="totalEmployees">Loading...</span></p>
        <div class="date-picker">
            <input type="date" id="startDate" />
            <input type="date" id="endDate" />
            <button onclick="updateDateRange()">Apply</button>
        </div>
    </div>

     <!-- Action Buttons -->
    <div class="action-buttons">
        <button onclick="toggleEmployeeStatus()">Show Employee Status</button>
        <button onclick="exportReport()">Export Report</button>
    </div>
    
    <!-- Department Filter -->
    <div class="filter-container">
        <label for="departmentFilter">Filter by Department:</label>
        <select id="departmentFilter" onchange="filterByDepartment()">
            <option value="all">All Departments</option>
            <!-- Department options will be added dynamically -->
        </select>
    </div>
    
    <!-- Timeline Legend -->
    <div class="timeline-legend">
        <div class="legend-item">
            <div class="legend-color working"></div>
            <span class="legend-label">Working</span>
        </div>
        <div class="legend-item">
            <div class="legend-color break"></div>
            <span class="legend-label">Break</span>
        </div>
        <div class="legend-item">
            <div class="legend-color lunch"></div>
            <span class="legend-label">Lunch</span>
        </div>
        <div class="legend-item">
            <div class="legend-color clocked-out"></div>
            <span class="legend-label">Clocked Out</span>
        </div>
        <div class="legend-item">
            <div class="legend-color violation"></div>
            <span class="legend-label">Break/Lunch Violation</span>
        </div>
    </div>

    <!-- Employee Status Grid -->
    <div id="employeeStatusGrid" class="employee-status-grid" style="display: none;"></div>

    <!-- Employee Timeline -->
    <div id="employeeTimeline"></div>

    <script>
        // Fetch employee data
        const fetchEmployees = fetch('https://raw.githubusercontent.com/SCOSeanKly/TimeKeeperReports/main/TimeKeeperEmployees.json')
            .then(response => response.json());

        // Fetch clocking data
        const fetchClockingData = fetch('https://raw.githubusercontent.com/SCOSeanKly/TimeKeeperReports/main/timekeeper_entries.json')
            .then(response => response.json());

        // Default to last working week (starting on Monday)
        const today = new Date();
        const lastMonday = new Date(today);
        lastMonday.setDate(today.getDate() - ((today.getDay() + 6) % 7) - 0);
        const lastSunday = new Date(lastMonday);
        lastSunday.setDate(lastMonday.getDate() + 6);

        // Set default date range in the date picker
        document.getElementById('startDate').value = lastMonday.toISOString().split('T')[0];
        document.getElementById('endDate').value = lastSunday.toISOString().split('T')[0];

        // Format hours as hours and minutes (e.g., "8h 30m")
        function formatHours(hours) {
            const h = Math.floor(hours);
            const m = Math.round((hours - h) * 60);
            return `${h}h ${m}m`;
        }

        // Helper to format hours as decimal (e.g., "8.50")
        function formatDecimalHours(hours) {
            return hours.toFixed(2);
        }






// Export CSV Report
function exportReport() {
    const startDate = document.getElementById('startDate').value;
    const endDate = document.getElementById('endDate').value;
    const dateFormatter = new Intl.DateTimeFormat('en-US', { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' });

    // Format the date range header
    const startDateStr = dateFormatter.format(new Date(startDate));
    const endDateStr = dateFormatter.format(new Date(endDate));

    let csvContent = "Time Keeping Report\n";
    csvContent += `Date Range: ${startDateStr} to ${endDateStr}\n\n`;
    csvContent += "Employee,Department,Scheduled Hours,Date,Clock In,Tea Break Start,Tea Break End,Total Tea Break,Lunch Start,Lunch End,Total Lunch Break,Clock Out,Total Time,Notes\n";

    // Fetch data and generate CSV
    Promise.all([fetchEmployees, fetchClockingData])
        .then(([employees, clockingData]) => {
            // Filter clocking data for the selected date range
            const filteredClockingData = clockingData.filter(entry => {
                const entryDate = new Date(entry.timestamp).toISOString().split('T')[0];
                return entryDate >= startDate && entryDate <= endDate;
            });

            // Create a map of employees for quick lookup by ID
            const employeeMap = new Map();
            employees.forEach(employee => {
                employeeMap.set(employee.id, employee);
            });

            // Group clocking data by employee and by day
            const employeeClockingMap = new Map();
            filteredClockingData.forEach(entry => {
                if (!employeeClockingMap.has(entry.employeeId)) {
                    employeeClockingMap.set(entry.employeeId, {});
                }
                const date = new Date(entry.timestamp).toISOString().split('T')[0];
                if (!employeeClockingMap.get(entry.employeeId)[date]) {
                    employeeClockingMap.get(entry.employeeId)[date] = [];
                }
                employeeClockingMap.get(entry.employeeId)[date].push(entry);
            });

            // Track total clocked time for the entire period for each employee
            const employeeTotalMinutes = new Map();

            // Generate CSV rows for each employee
            employeeClockingMap.forEach((days, employeeId) => {
                const employee = employeeMap.get(employeeId);
                if (employee) {
                    // Add employee header
                    csvContent += `\n\n========================================\n`;
                    csvContent += `${employee.name} - ${employee.department}\n`;
                    csvContent += `========================================\n`;

                    // Initialize period total for this employee
                    employeeTotalMinutes.set(employeeId, 0);

                    // Generate rows for each day
                    Object.entries(days).forEach(([date, entries]) => {
                        let clockIn = "-";
                        let teaBreakStart = "-";
                        let teaBreakEnd = "-";
                        let lunchStart = "-";
                        let lunchEnd = "-";
                        let clockOut = "-";
                        let notes = "";

                        // Sort entries chronologically
                        entries.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                        
                        // Track time segments
                        let lastClockIn = null;
                        let lastBreakStart = null;
                        let lastLunchStart = null;
                        
                        // Track total working time (excluding breaks)
                        let workingTimeMinutes = 0;
                        let teaBreakMinutes = 0;
                        let lunchBreakMinutes = 0;

                        // Process entries for the day
                        for (const entry of entries) {
                            const entryTime = new Date(entry.timestamp);
                            const timeStr = entryTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });

                            switch (entry.type) {
                                case 'Clock In':
                                    clockIn = timeStr;
                                    lastClockIn = entryTime;
                                    break;
                                    
                                case 'Clock Out':
                                    clockOut = timeStr;
                                    if (lastClockIn) {
                                        // Add working time up to clock out
                                        const workingSegment = (entryTime - lastClockIn) / (1000 * 60);
                                        workingTimeMinutes += workingSegment;
                                        lastClockIn = null;
                                    }
                                    break;
                                    
                                case 'Break Start':
                                    teaBreakStart = timeStr;
                                    lastBreakStart = entryTime;
                                    if (lastClockIn) {
                                        // Add working time up to break start
                                        const workingSegment = (entryTime - lastClockIn) / (1000 * 60);
                                        workingTimeMinutes += workingSegment;
                                        lastClockIn = null;
                                    }
                                    break;
                                    
                                case 'Break End':
                                    teaBreakEnd = timeStr;
                                    if (lastBreakStart) {
                                        // Calculate break duration
                                        const breakDuration = (entryTime - lastBreakStart) / (1000 * 60);
                                        teaBreakMinutes += breakDuration;
                                        lastBreakStart = null;
                                    }
                                    // Resume work tracking
                                    lastClockIn = entryTime;
                                    break;
                                    
                                case 'Lunch Start':
                                    lunchStart = timeStr;
                                    lastLunchStart = entryTime;
                                    if (lastClockIn) {
                                        // Add working time up to lunch start
                                        const workingSegment = (entryTime - lastClockIn) / (1000 * 60);
                                        workingTimeMinutes += workingSegment;
                                        lastClockIn = null;
                                    }
                                    break;
                                    
                                case 'Lunch End':
                                    lunchEnd = timeStr;
                                    if (lastLunchStart) {
                                        // Calculate lunch duration
                                        const lunchDuration = (entryTime - lastLunchStart) / (1000 * 60);
                                        lunchBreakMinutes += lunchDuration;
                                        lastLunchStart = null;
                                    }
                                    // Resume work tracking
                                    lastClockIn = entryTime;
                                    break;
                            }
                        }

                        // Handle edge case where the day ends without clocking out
                        if (lastClockIn) {
                            // Add note about unclosed session
                            notes += notes.isEmpty ? "Unclosed session" : ", Unclosed session";
                        }

                        // Format tea and lunch break totals
                        const totalTeaBreak = teaBreakMinutes > 0 ? `${Math.round(teaBreakMinutes)}m` : "0m";
                        const totalLunchBreak = lunchBreakMinutes > 0 ? `${Math.round(lunchBreakMinutes)}m` : "0m";

                        // Calculate total working time
                        const hours = Math.floor(workingTimeMinutes / 60);
                        const minutes = Math.round(workingTimeMinutes % 60);
                        const totalTime = `${hours}h ${minutes}m`;

                        // Add to employee's total for the period
                        employeeTotalMinutes.set(
                            employeeId, 
                            employeeTotalMinutes.get(employeeId) + workingTimeMinutes
                        );

                        // Add row to CSV
                        const row = [
                            `"${employee.name}"`,
                            `"${employee.department}"`,
                            `"${employee.startTime} - ${employee.finishTime}"`,
                            `"${date}"`,
                            `"${clockIn}"`,
                            `"${teaBreakStart}"`,
                            `"${teaBreakEnd}"`,
                            `"${totalTeaBreak}"`,
                            `"${lunchStart}"`,
                            `"${lunchEnd}"`,
                            `"${totalLunchBreak}"`,
                            `"${clockOut}"`,
                            `"${totalTime}"`,
                            `"${notes}"`
                        ].join(',');

                        csvContent += row + '\n';
                    });

                    // Add period total for this employee
                    const totalPeriodMinutes = employeeTotalMinutes.get(employeeId);
                    const periodHours = Math.floor(totalPeriodMinutes / 60);
                    const periodMinutes = Math.round(totalPeriodMinutes % 60);
                    csvContent += `"PERIOD TOTAL","","","","","","","","","","","","${periodHours}h ${periodMinutes}m",""\n`;
                }
            });

            // Trigger download
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `TimeKeeperReport_${startDate}_to_${endDate}.csv`;
            link.click();
        })
        .catch(error => console.error('Error exporting report:', error));
}











        

        // Enhanced function to calculate total hours worked with detailed breakdown
function calculateDetailedHours(entries) {
    // Sort entries by timestamp to ensure chronological order
    entries.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
    
    // Find first clock in and last clock out to calculate total attendance time
    const firstEntry = entries[0];
    const lastEntry = entries[entries.length - 1];
    
    let firstClockIn = null;
    let lastClockOut = null;
    
    // Find first clock in
    for (const entry of entries) {
        if (entry.type === 'Clock In') {
            firstClockIn = new Date(entry.timestamp);
            break;
        }
    }
    
    // Find last clock out
    for (let i = entries.length - 1; i >= 0; i--) {
        if (entries[i].type === 'Clock Out') {
            lastClockOut = new Date(entries[i].timestamp);
            break;
        }
    }
    
    // Calculate total attendance time (from first clock in to last clock out)
    let totalAttendanceMilliseconds = 0;
    if (firstClockIn && lastClockOut) {
        totalAttendanceMilliseconds = lastClockOut - firstClockIn;
    } else if (firstClockIn) {
        // If no clock out, use the last entry time
        totalAttendanceMilliseconds = new Date(lastEntry.timestamp) - firstClockIn;
    }
    
    // Calculate total break time
    let totalBreakMilliseconds = 0;
    let breakStartTime = null;
    
    for (const entry of entries) {
        const entryTime = new Date(entry.timestamp);
        
        if (entry.type === 'Break Start' || entry.type === 'Lunch Start') {
            breakStartTime = entryTime;
        } else if ((entry.type === 'Break End' || entry.type === 'Lunch End') && breakStartTime) {
            // Calculate break duration
            totalBreakMilliseconds += entryTime - breakStartTime;
            breakStartTime = null;
        }
    }
    
    // If there's an unclosed break, don't count it
    // (This is a business decision - you might want to handle unclosed breaks differently)
    
    // Convert to hours
    const totalAttendanceHours = totalAttendanceMilliseconds / (1000 * 60 * 60);
    const totalBreakHours = totalBreakMilliseconds / (1000 * 60 * 60);
    const totalWorkedHours = totalAttendanceHours - totalBreakHours;
    
    return {
        attendanceHours: totalAttendanceHours,
        breakHours: totalBreakHours,
        workedHours: totalWorkedHours,
        // Also return formatted times
        formatted: {
            attendance: formatHours(totalAttendanceHours),
            breaks: formatHours(totalBreakHours),
            worked: formatHours(totalWorkedHours)
        }
    };
}
        // Function to calculate live hours worked for today
// Function to calculate live hours worked for today
function calculateLiveHoursWorked(entries) {
    const now = new Date();
    
    // Filter entries to only include today's entries
    const todayEntries = entries.filter(entry => {
        const entryDate = new Date(entry.timestamp);
        return entryDate.toDateString() === now.toDateString();
    });
    
    // Sort entries by timestamp
    todayEntries.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
    
    let firstClockIn = null;
    let breakStartTime = null;
    let totalBreakMilliseconds = 0;
    let currentlyWorking = false;
    let onBreak = false;
    
    // Find first clock in
    for (const entry of todayEntries) {
        if (entry.type === 'Clock In') {
            firstClockIn = new Date(entry.timestamp);
            break;
        }
    }
    
    // Process all entries to calculate break time
    for (let i = 0; i < todayEntries.length; i++) {
        const entry = todayEntries[i];
        const entryTime = new Date(entry.timestamp);
        
        if (entry.type === 'Clock In') {
            currentlyWorking = true;
            onBreak = false;
        } else if (entry.type === 'Clock Out') {
            currentlyWorking = false;
            onBreak = false;
        } else if (entry.type === 'Break Start' || entry.type === 'Lunch Start') {
            breakStartTime = entryTime;
            currentlyWorking = false;
            onBreak = true;
        } else if ((entry.type === 'Break End' || entry.type === 'Lunch End') && breakStartTime) {
            // Calculate break duration
            totalBreakMilliseconds += entryTime - breakStartTime;
            breakStartTime = null;
            currentlyWorking = true;
            onBreak = false;
        }
    }
    
    // If still on break, add time from break start to now
    if (onBreak && breakStartTime) {
        totalBreakMilliseconds += now - breakStartTime;
    }
    
    // Calculate total attendance time from first clock in to now or last clock out
    let totalAttendanceMilliseconds = 0;
    let lastClockOutTime = null;
    
    // Find last clock out
    for (let i = todayEntries.length - 1; i >= 0; i--) {
        if (todayEntries[i].type === 'Clock Out') {
            lastClockOutTime = new Date(todayEntries[i].timestamp);
            break;
        }
    }
    
    if (firstClockIn) {
        if (currentlyWorking || onBreak) {
            // If still working or on break, calculate up to now
            totalAttendanceMilliseconds = now - firstClockIn;
        } else if (lastClockOutTime) {
            // If clocked out, calculate up to last clock out
            totalAttendanceMilliseconds = lastClockOutTime - firstClockIn;
        }
    }
    
    // Convert to hours
    const totalAttendanceHours = totalAttendanceMilliseconds / (1000 * 60 * 60);
    const totalBreakHours = totalBreakMilliseconds / (1000 * 60 * 60);
    const totalWorkedHours = totalAttendanceHours - totalBreakHours;
    
    return {
        attendanceHours: totalAttendanceHours,
        breakHours: totalBreakHours,
        workedHours: totalWorkedHours,
        currentlyWorking,
        onBreak,
        formatted: {
            attendance: formatHours(totalAttendanceHours),
            breaks: formatHours(totalBreakHours),
            worked: formatHours(totalWorkedHours)
        }
    };
}

        // Create HTML for today's live hours display
        function createLiveHoursDisplay(employeeId, hoursData) {
            let statusText = 'Not Clocked In';
            let statusClass = '';
            
            if (hoursData.currentlyWorking) {
                statusText = 'Currently Working';
                statusClass = 'currently-working';
            } else if (hoursData.onBreak) {
                statusText = 'On Break';
                statusClass = 'on-break';
            }
            
            return `
                <div class="live-hours ${statusClass}">
                    <div class="live-status">
                        <span class="status-text">${statusText}</span>
                        <span class="live-indicator">●</span>
                    </div>
                    <div class="live-time">
                        <strong>Current Total:</strong> 
                        <span id="live-hours-${employeeId}" class="live-time-counter">${hoursData.formatted.worked}</span>
                    </div>
                </div>
                <div class="hours-calculation">
                    <div class="calculation-row">
                        <span class="label">Time Attended:</span>
                        <div class="value-container">
                            <span id="live-attendance-${employeeId}" class="value">${hoursData.formatted.attendance}</span>
                            <span class="decimal-value">(${formatDecimalHours(hoursData.attendanceHours)}h)</span>
                        </div>
                    </div>
                    <div class="calculation-row">
                        <span class="label">Combined Break Time:</span>
                        <div class="value-container">
                            <span id="live-break-${employeeId}" class="value">${hoursData.formatted.breaks}</span>
                            <span class="decimal-value">(${formatDecimalHours(hoursData.breakHours)}h)</span>
                        </div>
                    </div>
                    <div class="calculation-row total">
                        <span class="label">Total Worked:</span>
                        <div class="value-container">
                            <span id="live-total-${employeeId}" class="value">${hoursData.formatted.worked}</span>
                            <span class="decimal-value">(${formatDecimalHours(hoursData.workedHours)}h)</span>
                        </div>
                    </div>
                </div>
            `;
        }

        // Create HTML for regular day hours display
        function createRegularHoursDisplay(hoursData) {
            return `
                <div class="hours-calculation">
                    <div class="calculation-row">
                        <span class="label">Time Attended:</span>
                        <div class="value-container">
                            <span class="value">${hoursData.formatted.attendance}</span>
                            <span class="decimal-value">(${formatDecimalHours(hoursData.attendanceHours)}h)</span>
                        </div>
                    </div>
                    <div class="calculation-row">
                        <span class="label">Break Time:</span>
                        <div class="value-container">
                            <span class="value">${hoursData.formatted.breaks}</span>
                            <span class="decimal-value">(${formatDecimalHours(hoursData.breakHours)}h)</span>
                        </div>
                    </div>
                    <div class="calculation-row total">
                        <span class="label">Total Worked:</span>
                        <div class="value-container">
                            <span class="value">${hoursData.formatted.worked}</span>
                            <span class="decimal-value">(${formatDecimalHours(hoursData.workedHours)}h)</span>
                        </div>
                    </div>
                </div>
            `;
        }

        // Function to update live hours display
        function updateLiveHoursDisplay() {
            const now = new Date();
            const today = now.toISOString().split('T')[0];
            
            // Only update during work hours (7am-7pm) or if you want to update at all hours, remove this check
            const hour = now.getHours();
            if (hour < 7 || hour >= 19) {
                // Outside work hours, schedule next update at 7am tomorrow
                const tomorrow = new Date(now);
                tomorrow.setDate(tomorrow.getDate() + 1);
                tomorrow.setHours(7, 0, 0, 0);
                const timeUntilTomorrow = tomorrow - now;
                setTimeout(updateLiveHoursDisplay, timeUntilTomorrow);
                return;
            }
            
            Promise.all([
                fetch('https://raw.githubusercontent.com/SCOSeanKly/TimeKeeperReports/main/TimeKeeperEmployees.json'),
                fetch('https://raw.githubusercontent.com/SCOSeanKly/TimeKeeperReports/main/timekeeper_entries.json')
            ])
            .then(responses => Promise.all(responses.map(response => response.json())))
            .then(([employees, clockingData]) => {
                // Filter entries for today
                const todayEntries = clockingData.filter(entry => {
                    const entryDate = new Date(entry.timestamp).toISOString().split('T')[0];
                    return entryDate === today;
                });
                
                // Group entries by employee
                const employeeEntriesMap = new Map();
                todayEntries.forEach(entry => {
                    if (!employeeEntriesMap.has(entry.employeeId)) {
                        employeeEntriesMap.set(entry.employeeId, []);
                    }
                    employeeEntriesMap.get(entry.employeeId).push(entry);
                });
                
                // Update live hours for each employee
                employeeEntriesMap.forEach((entries, employeeId) => {
                    const liveHoursElement = document.getElementById(`live-hours-${employeeId}`);
                    const liveAttendanceElement = document.getElementById(`live-attendance-${employeeId}`);
                    const liveBreakElement = document.getElementById(`live-break-${employeeId}`);
                    const liveTotalElement = document.getElementById(`live-total-${employeeId}`);
                    
                    if (liveHoursElement) {
                        const liveHours = calculateLiveHoursWorked(entries);
                        
                        // Update live time counter
                        liveHoursElement.textContent = liveHours.formatted.worked;
                        
                        // Update detailed breakdown if elements exist
                        if (liveAttendanceElement) {
                            liveAttendanceElement.textContent = liveHours.formatted.attendance;
                            liveAttendanceElement.nextElementSibling.textContent = 
                                `(${formatDecimalHours(liveHours.attendanceHours)}h)`;
                        }
                        
                        if (liveBreakElement) {
                            liveBreakElement.textContent = liveHours.formatted.breaks;
                            liveBreakElement.nextElementSibling.textContent = 
                                `(${formatDecimalHours(liveHours.breakHours)}h)`;
                        }
                        
                        if (liveTotalElement) {
                            liveTotalElement.textContent = liveHours.formatted.worked;
                            liveTotalElement.nextElementSibling.textContent = 
                                `(${formatDecimalHours(liveHours.workedHours)}h)`;
                        }
                        
                        // Add visual indicator based on status
                        const parentContainer = liveHoursElement.closest('.live-hours');
                        if (liveHours.currentlyWorking) {
                            parentContainer.classList.add('currently-working');
                            parentContainer.classList.remove('on-break');
                            parentContainer.querySelector('.status-text').textContent = 'Currently Working';
                        } else if (liveHours.onBreak) {
                            parentContainer.classList.add('on-break');
                            parentContainer.classList.remove('currently-working');
                            parentContainer.querySelector('.status-text').textContent = 'On Break';
                        } else {
                            parentContainer.classList.remove('currently-working', 'on-break');
                            parentContainer.querySelector('.status-text').textContent = 'Not Clocked In';
                        }
                    }
                });
                
                // Schedule next update in 1 minute
                setTimeout(updateLiveHoursDisplay, 60000);
            })
            .catch(error => {
                console.error('Error updating live hours:', error);
                // If error, try again in 5 minutes
                setTimeout(updateLiveHoursDisplay, 300000);
            });
        }

        // Function to update the date range
        function updateDateRange() {
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            loadData(startDate, endDate);
        }

        // Function to load departments and populate filter dropdown
        function loadDepartments(employees) {
            const departmentFilter = document.getElementById('departmentFilter');
            
            // Clear existing options except "All Departments"
            while (departmentFilter.options.length > 1) {
                departmentFilter.remove(1);
            }
            
            // Get unique departments
            const departments = [...new Set(employees.map(employee => employee.department))];
            
            // Add department options
            departments.forEach(department => {
                const option = document.createElement('option');
                option.value = department;
                option.textContent = department;
                departmentFilter.appendChild(option);
            });
        }

        // Function to filter employees by department
       function filterByDepartment() {
    const department = document.getElementById('departmentFilter').value;
    
    // Filter the employee timeline containers
    const employeeContainers = document.querySelectorAll('.employee-container');
    employeeContainers.forEach(container => {
        if (department === 'all' || container.dataset.department === department) {
            container.style.display = 'block';
        } else {
            container.style.display = 'none';
        }
    });
    
    // Filter the employee status cards as well
    const statusCards = document.querySelectorAll('.employee-status-card');
    statusCards.forEach(card => {
        if (department === 'all' || card.dataset.department === department) {
            card.style.display = 'block';
        } else {
            card.style.display = 'none';
        }
    });
}

        // Function to load data for a specific date range
        function loadData(startDate, endDate) {
            Promise.all([fetchEmployees, fetchClockingData])
                .then(([employees, clockingData]) => {
                    const container = document.getElementById('employeeTimeline');
                    const dateRange = document.getElementById('dateRange');
                    const totalEmployees = document.getElementById('totalEmployees');

                    // Load departments for filter
                    loadDepartments(employees);

                    // Filter clocking data for the selected date range
                    const filteredClockingData = clockingData.filter(entry => {
                        const entryDate = new Date(entry.timestamp).toISOString().split('T')[0];
                        return entryDate >= startDate && entryDate <= endDate;
                    });

                    // Set report header information
                    dateRange.textContent = `${startDate} to ${endDate}`;
                    totalEmployees.textContent = employees.length;

                    // Create a map of employees for quick lookup by ID
                    const employeeMap = new Map();
                    employees.forEach(employee => {
                        employeeMap.set(employee.id, employee);
                    });

                    // Group clocking data by employee and by day
                    const employeeClockingMap = new Map();
                    filteredClockingData.forEach(entry => {
                        if (!employeeClockingMap.has(entry.employeeId)) {
                            employeeClockingMap.set(entry.employeeId, {});
                        }
                        const date = new Date(entry.timestamp).toISOString().split('T')[0];
                        if (!employeeClockingMap.get(entry.employeeId)[date]) {
                            employeeClockingMap.get(entry.employeeId)[date] = [];
                        }
                        employeeClockingMap.get(entry.employeeId)[date].push(entry);
                    });

                    // Clear existing content
                    container.innerHTML = '';

                    // Display timeline for each employee
                    employeeClockingMap.forEach((days, employeeId) => {
                        const employee = employeeMap.get(employeeId);
                        if (employee) {
                            // Create employee container
                            const employeeDiv = document.createElement('div');
                            employeeDiv.className = 'employee-container';
                            employeeDiv.id = `employee-${employeeId}`;
                            employeeDiv.dataset.department = employee.department;

                            // Add employee header
                            const header = document.createElement('div');
                            header.className = 'employee-header';
                            header.textContent = `${employee.name} (${employee.department})`;
                            employeeDiv.appendChild(header);

                            // Track employee total hours
                            let employeeTotalAttendance = 0;
                            let employeeTotalBreaks = 0;
                            let employeeTotalWorked = 0;

                            // Add timeline for each day
                            Object.entries(days).forEach(([date, entries]) => {
                                const dayDiv = document.createElement('div');
                                dayDiv.className = 'day-container';

                                // Add day header
                                const dayHeader = document.createElement('div');
                                dayHeader.className = 'day-header';
                                dayHeader.textContent = `Date: ${new Date(date).toLocaleDateString('en-US', { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' })}`;
                                dayDiv.appendChild(dayHeader);

                                // Add timeline scale
                                const timelineScale = document.createElement('div');
                                timelineScale.className = 'timeline-scale';
                                for (let hour = 7; hour <= 19; hour += 2) {
                                    const timeLabel = document.createElement('span');
                                    timeLabel.textContent = `${hour}:00`;
                                    timelineScale.appendChild(timeLabel);
                                }
                                dayDiv.appendChild(timelineScale);

                                // Add timeline
                                const timeline = document.createElement('div');
                                timeline.className = 'timeline';

                                // Sort entries by timestamp
                                entries.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                                // Define the start and end of the workday (7:00 AM to 7:00 PM)
                                const workdayStart = new Date(`${date}T07:00:00Z`);
                                const workdayEnd = new Date(`${date}T19:00:00Z`);
                                const totalDuration = workdayEnd - workdayStart;

                                // Add hourly markers
                                for (let hour = 7; hour <= 19; hour++) {
                                    const markerTime = new Date(`${date}T${String(hour).padStart(2, '0')}:00:00Z`);
                                    const markerPosition = ((markerTime - workdayStart) / totalDuration) * 100;

                                    // Create marker element
                                    const marker = document.createElement('div');
                                    marker.className = 'marker';
                                    marker.style.left = `${markerPosition}%`;

                                    // Add label for the hour
                                    const markerLabel = document.createElement('div');
                                    markerLabel.className = 'marker-label';
                                    markerLabel.textContent = `${hour}:00`;
                                    marker.appendChild(markerLabel);

                                    timeline.appendChild(marker);
                                }

                                // Add the "no clockings" segment before the first clock-in
                                const firstEvent = new Date(entries[0].timestamp);
                                const noClockingsBefore = firstEvent - workdayStart;
                                if (noClockingsBefore > 0) {
                                    const noClockingsSegment = document.createElement('div');
                                    noClockingsSegment.className = 'progress-bar clocked-out';
                                    noClockingsSegment.style.width = `${(noClockingsBefore / totalDuration) * 100}%`;
                                    noClockingsSegment.style.left = '0%';
                                    timeline.appendChild(noClockingsSegment);
                                }

                                // Track break and lunch periods for violation checking
                                let breakStartTime = null;
                                let lunchStartTime = null;
                                
                                // Create progress bar segments for clockings
                                let previousTime = firstEvent;
                                let currentState = 'clocked-out'; // Default state
                                
                                // If first event is Clock In, set state to working
                                if (entries[0].type === 'Clock In') {
                                    currentState = 'working';
                                }

                                // Process all entries
                                for (let i = 0; i < entries.length; i++) {
                                    const entry = entries[i];
                                    const eventTime = new Date(entry.timestamp);
                                    const segmentDuration = eventTime - previousTime;
                                    
                                    // Skip creating a segment if there's no duration
                                    if (segmentDuration <= 0) {
                                        // Update state based on the event type
                                        if (entry.type === 'Clock In') {
                                            currentState = 'working';
                                        } else if (entry.type === 'Break Start') {
                                            currentState = 'break';
                                            breakStartTime = eventTime;
                                        } else if (entry.type === 'Break End') {
                                            currentState = 'working';
                                        } else if (entry.type === 'Lunch Start') {
                                            currentState = 'lunch';
                                            lunchStartTime = eventTime;
                                        } else if (entry.type === 'Lunch End') {
                                            currentState = 'working';
                                        } else if (entry.type === 'Clock Out') {
                                            currentState = 'clocked-out';
                                        }
                                        
                                        previousTime = eventTime;
                                        continue;
                                    }

                                    // Create segment with current state
                                    const segment = document.createElement('div');
                                    segment.className = `progress-bar ${currentState}`;
                                    segment.style.width = `${(segmentDuration / totalDuration) * 100}%`;
                                    segment.style.left = `${((previousTime - workdayStart) / totalDuration) * 100}%`;
                                    timeline.appendChild(segment);
                                    
                                    // Check for break violations (if applicable)
                                    if (currentState === 'break' && entry.type === 'Break End') {
                                        const breakDuration = eventTime - breakStartTime;
                                        const breakMinutes = breakDuration / (1000 * 60);
                                        
                                        // If break is longer than 15 minutes, mark as violation
                                        if (breakMinutes > 15) {
                                            const violationStart = new Date(breakStartTime.getTime() + (15 * 60 * 1000));
                                            const violationDuration = eventTime - violationStart;
                                            const violationWidth = (violationDuration / totalDuration) * 100;
                                            const violationLeft = ((violationStart - workdayStart) / totalDuration) * 100;
                                            
                                            const violationMarker = document.createElement('div');
                                            violationMarker.className = 'break-violation';
                                            violationMarker.style.width = `${violationWidth}%`;
                                            violationMarker.style.left = `${violationLeft}%`;
                                            
                                            const tooltip = document.createElement('div');
                                            tooltip.className = 'tooltip';
                                            tooltip.textContent = `Break violation: ${Math.round(breakMinutes)} min (15 min limit)`;
                                            violationMarker.appendChild(tooltip);
                                            
                                            timeline.appendChild(violationMarker);
                                        }
                                    }
                                    
                                    // Check for lunch violations (if applicable)
                                    if (currentState === 'lunch' && entry.type === 'Lunch End') {
                                        const lunchDuration = eventTime - lunchStartTime;
                                        const lunchMinutes = lunchDuration / (1000 * 60);
                                        
                                        // If lunch is longer than 30 minutes, mark as violation
                                        if (lunchMinutes > 30) {
                                            const violationStart = new Date(lunchStartTime.getTime() + (30 * 60 * 1000));
                                            const violationDuration = eventTime - violationStart;
                                            const violationWidth = (violationDuration / totalDuration) * 100;
                                            const violationLeft = ((violationStart - workdayStart) / totalDuration) * 100;
                                            
                                            const violationMarker = document.createElement('div');
                                            violationMarker.className = 'break-violation';
                                            violationMarker.style.width = `${violationWidth}%`;
                                            violationMarker.style.left = `${violationLeft}%`;
                                            
                                            const tooltip = document.createElement('div');
                                            tooltip.className = 'tooltip';
                                            tooltip.textContent = `Lunch violation: ${Math.round(lunchMinutes)} min (30 min limit)`;
                                            violationMarker.appendChild(tooltip);
                                            
                                            timeline.appendChild(violationMarker);
                                        }
                                    }

                                    // Update state for the next segment
                                    if (entry.type === 'Clock In') {
                                        currentState = 'working';
                                    } else if (entry.type === 'Break Start') {
                                        currentState = 'break';
                                        breakStartTime = eventTime;
                                    } else if (entry.type === 'Break End') {
                                        currentState = 'working';
                                    } else if (entry.type === 'Lunch Start') {
                                        currentState = 'lunch';
                                        lunchStartTime = eventTime;
                                    } else if (entry.type === 'Lunch End') {
                                        currentState = 'working';
                                    } else if (entry.type === 'Clock Out') {
                                        currentState = 'clocked-out';
                                    }
                                    
                                    previousTime = eventTime;
                                }

                                // Add the "no clockings" segment after the last clock-out
                                const lastEvent = new Date(entries[entries.length - 1].timestamp);
                                const noClockingsAfter = workdayEnd - lastEvent;
                                if (noClockingsAfter > 0) {
                                    const noClockingsSegment = document.createElement('div');
                                    // Use clocked-out style for the remaining time if the last event was a Clock Out
                                    // Otherwise, use the current state
                                    const lastEventType = entries[entries.length - 1].type;
                                    const finalState = lastEventType === 'Clock Out' ? 'clocked-out' : currentState;
                                    noClockingsSegment.className = `progress-bar ${finalState}`;
                                    noClockingsSegment.style.width = `${(noClockingsAfter / totalDuration) * 100}%`;
                                    noClockingsSegment.style.left = `${((lastEvent - workdayStart) / totalDuration) * 100}%`;
                                    timeline.appendChild(noClockingsSegment);
                                }

                                dayDiv.appendChild(timeline);

                                // Add notes (if any)
                                const notes = document.createElement('div');
                                notes.className = 'notes';
                                notes.textContent = 'Notes: [Add notes here]';
                                dayDiv.appendChild(notes);

                                // Calculate and display hours for the day
                                const isToday = new Date(date).toDateString() === new Date().toDateString();
                                const hoursData = calculateDetailedHours(entries);
                                
                                // Add employee's day to total hours
                                employeeTotalAttendance += hoursData.attendanceHours;
                                employeeTotalBreaks += hoursData.breakHours;
                                employeeTotalWorked += hoursData.workedHours;
                                
                                // Create hours breakdown
                                const totalHoursDiv = document.createElement('div');
                                totalHoursDiv.className = 'hours-breakdown';
                                
                                if (isToday) {
                                    // For today, show live hours with detailed breakdown
                                    const liveHoursData = calculateLiveHoursWorked(entries);
                                    totalHoursDiv.innerHTML = createLiveHoursDisplay(employeeId, liveHoursData);
                                } else {
                                    // Regular display for past days with detailed breakdown
                                    totalHoursDiv.innerHTML = createRegularHoursDisplay(hoursData);
                                }
                                
                                dayDiv.appendChild(totalHoursDiv);
                                employeeDiv.appendChild(dayDiv);
                            });

                            // Add employee total hours summary
                         

                            container.appendChild(employeeDiv);
                        }
                    });

                    // Apply initial department filter
                    filterByDepartment();

                    // Start the live hours update for today
                    if (document.querySelector('.live-time-counter')) {
                        updateLiveHoursDisplay();
                    }

                    // Animate progress bars with a slight delay to ensure proper rendering
                    setTimeout(() => {
                        document.querySelectorAll('.progress-bar').forEach(bar => {
                            const originalWidth = bar.style.width;
                            bar.style.width = '0';
                            
                            // Force a reflow to ensure the animation works
                            void bar.offsetWidth;
                            
                            // Set back to original width to trigger animation
                            bar.style.width = originalWidth;
                        });
                    }, 300);
                })
                .catch(error => console.error('Error fetching data:', error));
        }

        // Function to toggle employee status visibility
        function toggleEmployeeStatus() {
            const employeeStatusGrid = document.getElementById('employeeStatusGrid');
            if (employeeStatusGrid.style.display === 'none') {
                showEmployeeStatus();
                employeeStatusGrid.style.display = 'grid';
            } else {
                employeeStatusGrid.style.display = 'none';
            }
        }

        // Function to show employee status
function showEmployeeStatus() {
    const employeeStatusGrid = document.getElementById('employeeStatusGrid');
    employeeStatusGrid.innerHTML = ''; // Clear previous content

    // Get today's date in YYYY-MM-DD format
    const today = new Date().toISOString().split('T')[0];

    // Fetch both employees and clocking data
    Promise.all([
        fetch('https://raw.githubusercontent.com/SCOSeanKly/TimeKeeperReports/main/TimeKeeperEmployees.json'),
        fetch('https://raw.githubusercontent.com/SCOSeanKly/TimeKeeperReports/main/timekeeper_entries.json')
    ])
    .then(responses => Promise.all(responses.map(response => response.json())))
    .then(([employees, clockingData]) => {
        // Filter entries for today
        const todayEntries = clockingData.filter(entry => {
            const entryDate = new Date(entry.timestamp).toISOString().split('T')[0];
            return entryDate === today;
        });

        // Group entries by employee
        const employeeStatusMap = new Map();
        todayEntries.forEach(entry => {
            if (!employeeStatusMap.has(entry.employeeId)) {
                employeeStatusMap.set(entry.employeeId, []);
            }
            employeeStatusMap.get(entry.employeeId).push(entry);
        });

        // Create a card for every employee - even those without entries today
        employees.forEach(employee => {
            // Check if employee has entries today
            const entries = employeeStatusMap.get(employee.id) || [];
            
            // Determine status based on entries
            let statusClass = 'clocked-out'; // Default status
            let statusText = 'Not Clocked In';
            let clockInTimeText = 'No clock-in today';
            let hoursText = '';
            
            if (entries.length > 0) {
                // Sort entries by timestamp
                entries.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                
                // Get the latest entry to determine current status
                const latestEntry = entries[entries.length - 1];
                
                // Calculate hours
                const hoursData = calculateLiveHoursWorked(entries);
                hoursText = `Hours Worked: ${hoursData.formatted.worked}`;
                
                // Update clock-in time text
                const firstClockIn = entries.find(e => e.type === 'Clock In');
                if (firstClockIn) {
                    clockInTimeText = `First Clock In: ${new Date(firstClockIn.timestamp).toLocaleTimeString()}`;
                }
                
                // Determine the status class based on the latest entry type
                if (latestEntry.type === 'Clock In') {
                    statusClass = 'clocked-in';
                    statusText = 'Working';
                } else if (latestEntry.type === 'Break Start') {
                    statusClass = 'on-break';
                    statusText = 'On Break';
                } else if (latestEntry.type === 'Lunch Start') {
                    statusClass = 'on-lunch';
                    statusText = 'On Lunch';
                } else if (latestEntry.type === 'Break End' || latestEntry.type === 'Lunch End') {
                    statusClass = 'clocked-in'; // After break/lunch end, employee is clocked in
                    statusText = 'Working';
                } else if (latestEntry.type === 'Clock Out') {
                    statusClass = 'clocked-out';
                    statusText = 'Clocked Out';
                }
            }
            
            // Create employee status card
            const card = document.createElement('div');
            card.className = `employee-status-card ${statusClass}`;
            
            // Add department data attribute for filtering
            card.dataset.department = employee.department;
            
            // Set inline styles for text color as a fallback method
            const textColor = (statusClass === 'on-break') ? 'black' : 'white';
            
            card.onclick = () => {
                const employeeElement = document.getElementById(`employee-${employee.id}`);
                if (employeeElement) {
                    employeeElement.scrollIntoView({ behavior: 'smooth' });
                } else {
                    alert(`No timeline data available for ${employee.name} in the selected date range`);
                }
            };
            
            // Add employee name with inline styles
            const name = document.createElement('h3');
            name.textContent = employee.name;
            name.style.color = textColor;
            card.appendChild(name);
            
            // Add department with inline styles
            const department = document.createElement('p');
            department.textContent = `Department: ${employee.department}`;
            department.style.color = textColor;
            card.appendChild(department);
            
            // Add clock-in time with inline styles
            const clockInTime = document.createElement('p');
            clockInTime.textContent = clockInTimeText;
            clockInTime.style.color = textColor;
            card.appendChild(clockInTime);
            
            // Add hours worked if available
            if (hoursText) {
                const hours = document.createElement('p');
                hours.textContent = hoursText;
                hours.style.color = textColor;
                card.appendChild(hours);
            }
            
            // Add current status with inline styles
            const status = document.createElement('p');
            status.textContent = `Status: ${statusText}`;
            status.style.color = textColor;
            card.appendChild(status);
            
            employeeStatusGrid.appendChild(card);
        });
        
        // Add inline style to ensure background colors aren't overridden
        document.querySelectorAll('.employee-status-card.clocked-out').forEach(card => {
            card.style.backgroundColor = '#333';
        });
        document.querySelectorAll('.employee-status-card.clocked-in').forEach(card => {
            card.style.backgroundColor = '#4CAF50';
        });
        document.querySelectorAll('.employee-status-card.on-break').forEach(card => {
            card.style.backgroundColor = '#FFC107';
        });
        document.querySelectorAll('.employee-status-card.on-lunch').forEach(card => {
            card.style.backgroundColor = '#FF9800';
        });
        
        // Apply current department filter to the newly shown grid
        filterByDepartment();
    })
    .catch(error => {
        console.error('Error fetching data:', error);
        employeeStatusGrid.innerHTML = '<p>Error loading employee status data</p>';
    });
}

// Updated toggleEmployeeStatus function to ensure filter is applied
function toggleEmployeeStatus() {
    const employeeStatusGrid = document.getElementById('employeeStatusGrid');
    if (employeeStatusGrid.style.display === 'none') {
        showEmployeeStatus();
        employeeStatusGrid.style.display = 'grid';
    } else {
        employeeStatusGrid.style.display = 'none';
    }
}

        // Function to print the report
        function printReport() {
            window.print();
        }

        // Load data for the default date range
        loadData(lastMonday.toISOString().split('T')[0], lastSunday.toISOString().split('T')[0]);
    </script>
</body>
</html>