<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kerr & Smith Time Keeper Report</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .report-header {
            margin-bottom: 20px;
            padding: 20px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            position: relative;
        }
        .report-header h1 {
            font-size: 2em;
            margin-bottom: 10px;
            color: #333;
        }
        .report-header p {
            font-size: 1.1em;
            color: #555;
        }
        .date-picker {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }
        .date-picker input, .date-picker select {
            padding: 5px;
            font-size: 1em;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .employee-container {
            margin-bottom: 40px;
            padding: 20px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            page-break-inside: avoid;
        }
        .employee-header {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
        .employee-total-hours {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
            background-color: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
        }
        .day-container {
            margin-bottom: 20px;
        }
        .day-header {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
        .timeline {
            display: flex;
            align-items: center;
            height: 20px;
            background-color: #333;
            border-radius: 10px;
            position: relative;
            margin-bottom: 10px;
            overflow: hidden;
        }
        .timeline-scale {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #555;
        }
        .progress-bar {
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            width: 0;
            transition: width 0.8s ease-in-out;
        }
        .marker {
            position: absolute;
            top: 0;
            height: 100%;
            width: 1px;
            background-color: rgba(255, 255, 255, 0.5); /* Light gray line */
            z-index: 1;
        }
        .marker-label {
            position: absolute;
            top: -20px; /* Position above the timeline */
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8em;
            color: #555;
            white-space: nowrap;
        }
        .notes {
            margin-top: 10px;
            font-size: 0.9em;
            color: #555;
        }
        .total-hours {
            margin-top: 10px;
            font-weight: bold;
            font-size: 1.1em;
            background-color: #e0f7fa;
            padding: 10px;
            border-radius: 5px;
        }
        /* Colors for event types */
        .working { background-color: #4CAF50; }
        .break { background-color: #FFC107; }
        .lunch { background-color: #FF9800; }
        .clocked-out { background-color: #333; }
        
        /* Break violation indicators */
        .break-violation {
            position: absolute;
            top: 0;
            height: 100%;
            background-color: rgba(255, 0, 0, 0.5);
            z-index: 2;
        }
        
        /* Tooltip for break violations */
        .tooltip {
            position: absolute;
            top: -30px;
            background-color: #333;
            color: white;
            padding: 5px;
            border-radius: 3px;
            font-size: 0.8em;
            white-space: nowrap;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 10;
        }
        
        .break-violation:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }

        /* Live hours worked styling */
        .hours-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .live-hours {
            display: flex;
            align-items: center;
            background-color: #f0f0f0;
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
            color: #333;
        }

        .live-time-counter {
            margin-right: 8px;
        }

        .live-indicator {
            color: #f44336;
            font-size: 1.2em;
            animation: pulse 2s infinite;
        }

        .currently-working .live-indicator {
            color: #4CAF50;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }

        /* Grid card style for employee status */
        .employee-status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
            padding-bottom: 40px;
        }
        .employee-status-card {
            border: 1px solid #ddd;
            border-radius: 10px;
            padding: 15px;
            background-color: white;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease-in-out;
            cursor: pointer;
        }
        .employee-status-card:hover {
            transform: translateY(-5px);
        }
        .employee-status-card h3 {
            margin: 0 0 10px;
            font-size: 1.2em;
            color: #333;
        }
        .employee-status-card p {
            margin: 5px 0;
            font-size: 0.9em;
            color: #555;
        }
        /* Card colors based on status */
        .employee-status-grid .employee-status-card.clocked-out h3,
        .employee-status-grid .employee-status-card.clocked-out p {
            color: white !important;
        }

        .employee-status-grid .employee-status-card.clocked-in h3,
        .employee-status-grid .employee-status-card.clocked-in p {
            color: white !important;
        }

        .employee-status-grid .employee-status-card.on-break h3,
        .employee-status-grid .employee-status-card.on-break p {
            color: black !important;
        }

        .employee-status-grid .employee-status-card.on-lunch h3,
        .employee-status-grid .employee-status-card.on-lunch p {
            color: white !important;
        }

        /* Buttons */
        .action-buttons {
            margin-bottom: 20px;
        }
        .action-buttons button {
            padding: 10px 20px;
            font-size: 1em;
            border: none;
            border-radius: 5px;
            background-color: #04a9fd;
            color: white;
            cursor: pointer;
            margin-right: 10px;
            transition: background-color 0.2s ease-in-out;
        }
        .action-buttons button:hover {
            background-color: #0773f9;
        }
        
        /* Department filter */
        .filter-container {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
        }
        .filter-container label {
            margin-right: 10px;
            font-weight: bold;
        }
        .filter-container select {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        
        /* Legend for timeline colors */
        .timeline-legend {
            display: flex;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 5px;
            border-radius: 3px;
        }
        .legend-label {
            font-size: 0.9em;
        }
        .legend-color.working { background-color: #4CAF50; }
        .legend-color.break { background-color: #FFC107; }
        .legend-color.lunch { background-color: #FF9800; }
        .legend-color.clocked-out { background-color: #333; }
        .legend-color.violation { background-color: rgba(255, 0, 0, 0.5); }
    </style>
</head>
<body>
    <div class="report-header">
        <h1>Kerr & Smith Time Keeper</h1>
        <p>Date Range: <span id="dateRange">Loading...</span></p>
        <p>Total Employees: <span id="totalEmployees">Loading...</span></p>
        <div class="date-picker">
            <input type="date" id="startDate" />
            <input type="date" id="endDate" />
            <button onclick="updateDateRange()">Apply</button>
        </div>
    </div>

    <!-- Action Buttons -->
    <div class="action-buttons">
        <button onclick="toggleEmployeeStatus()">Show Employee Status</button>
        <!-- <button onclick="printReport()">Print Report</button> -->
    </div>
    
    <!-- Department Filter -->
    <div class="filter-container">
        <label for="departmentFilter">Filter by Department:</label>
        <select id="departmentFilter" onchange="filterByDepartment()">
            <option value="all">All Departments</option>
            <!-- Department options will be added dynamically -->
        </select>
    </div>
    
    <!-- Timeline Legend -->
    <div class="timeline-legend">
        <div class="legend-item">
            <div class="legend-color working"></div>
            <span class="legend-label">Working</span>
        </div>
        <div class="legend-item">
            <div class="legend-color break"></div>
            <span class="legend-label">Break</span>
        </div>
        <div class="legend-item">
            <div class="legend-color lunch"></div>
            <span class="legend-label">Lunch</span>
        </div>
        <div class="legend-item">
            <div class="legend-color clocked-out"></div>
            <span class="legend-label">Clocked Out</span>
        </div>
        <div class="legend-item">
            <div class="legend-color violation"></div>
            <span class="legend-label">Break/Lunch Violation</span>
        </div>
    </div>

    <!-- Employee Status Grid -->
    <div id="employeeStatusGrid" class="employee-status-grid" style="display: none;"></div>

    <!-- Employee Timeline -->
    <div id="employeeTimeline"></div>

    <script>
        // Fetch employee data
        const fetchEmployees = fetch('https://raw.githubusercontent.com/SCOSeanKly/TimeKeeperReports/main/TimeKeeperEmployees.json')
            .then(response => response.json());

        // Fetch clocking data
        const fetchClockingData = fetch('https://raw.githubusercontent.com/SCOSeanKly/TimeKeeperReports/main/timekeeper_entries.json')
            .then(response => response.json());

        // Default to last working week (starting on Monday)
        const today = new Date();
        const lastMonday = new Date(today);
        lastMonday.setDate(today.getDate() - ((today.getDay() + 6) % 7) - 0);
        const lastSunday = new Date(lastMonday);
        lastSunday.setDate(lastMonday.getDate() + 6);

        // Set default date range in the date picker
        document.getElementById('startDate').value = lastMonday.toISOString().split('T')[0];
        document.getElementById('endDate').value = lastSunday.toISOString().split('T')[0];

        // Function to calculate live hours worked for today
        function calculateLiveHoursWorked(entries) {
            const now = new Date();
            let totalMilliseconds = 0;
            let currentlyWorking = false;
            let lastClockIn = null;
            
            // Filter entries to only include today's entries
            const todayEntries = entries.filter(entry => {
                const entryDate = new Date(entry.timestamp);
                return entryDate.toDateString() === now.toDateString();
            });
            
            // Sort entries by timestamp
            todayEntries.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            
            // Process all entries to calculate time worked
            for (let i = 0; i < todayEntries.length; i++) {
                const entry = todayEntries[i];
                const entryTime = new Date(entry.timestamp);
                
                if (entry.type === 'Clock In') {
                    lastClockIn = entryTime;
                    currentlyWorking = true;
                } else if (entry.type === 'Clock Out' && lastClockIn) {
                    totalMilliseconds += entryTime - lastClockIn;
                    lastClockIn = null;
                    currentlyWorking = false;
                } else if ((entry.type === 'Break Start' || entry.type === 'Lunch Start') && lastClockIn) {
                    totalMilliseconds += entryTime - lastClockIn;
                    lastClockIn = null;
                    currentlyWorking = false;
                } else if ((entry.type === 'Break End' || entry.type === 'Lunch End')) {
                    lastClockIn = entryTime;
                    currentlyWorking = true;
                }
            }
            
            // If still clocked in, add time from last clock-in to now
            if (currentlyWorking && lastClockIn) {
                totalMilliseconds += now - lastClockIn;
            }
            
            // Convert to hours and minutes
            const totalSeconds = Math.floor(totalMilliseconds / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            
            return {
                hours,
                minutes,
                totalMilliseconds,
                currentlyWorking,
                formattedTime: `${hours}h ${minutes}m`
            };
        }

        // Function to update live hours display
        function updateLiveHoursDisplay() {
            const now = new Date();
            const today = now.toISOString().split('T')[0];
            
            // Only update during work hours (7am-7pm)
            const hour = now.getHours();
            if (hour < 7 || hour >= 19) {
                // Outside work hours, schedule next update at 7am tomorrow
                const tomorrow = new Date(now);
                tomorrow.setDate(tomorrow.getDate() + 1);
                tomorrow.setHours(7, 0, 0, 0);
                const timeUntilTomorrow = tomorrow - now;
                setTimeout(updateLiveHoursDisplay, timeUntilTomorrow);
                return;
            }
            
            Promise.all([
                fetch('https://raw.githubusercontent.com/SCOSeanKly/TimeKeeperReports/main/TimeKeeperEmployees.json'),
                fetch('https://raw.githubusercontent.com/SCOSeanKly/TimeKeeperReports/main/timekeeper_entries.json')
            ])
            .then(responses => Promise.all(responses.map(response => response.json())))
            .then(([employees, clockingData]) => {
                // Filter entries for today
                const todayEntries = clockingData.filter(entry => {
                    const entryDate = new Date(entry.timestamp).toISOString().split('T')[0];
                    return entryDate === today;
                });
                
                // Group entries by employee
                const employeeEntriesMap = new Map();
                todayEntries.forEach(entry => {
                    if (!employeeEntriesMap.has(entry.employeeId)) {
                        employeeEntriesMap.set(entry.employeeId, []);
                    }
                    employeeEntriesMap.get(entry.employeeId).push(entry);
                });
                
                // Update live hours for each employee
                employeeEntriesMap.forEach((entries, employeeId) => {
                    const liveHoursElement = document.getElementById(`live-hours-${employeeId}`);
                    if (liveHoursElement) {
                        const liveHours = calculateLiveHoursWorked(entries);
                        liveHoursElement.textContent = liveHours.formattedTime;
                        
                        // Add visual indicator if currently working
                        const parentContainer = liveHoursElement.closest('.live-hours');
                        if (liveHours.currentlyWorking) {
                            parentContainer.classList.add('currently-working');
                        } else {
                            parentContainer.classList.remove('currently-working');
                        }
                    }
                });
                
                // Schedule next update in 1 minute
                setTimeout(updateLiveHoursDisplay, 60000);
            })
            .catch(error => {
                console.error('Error updating live hours:', error);
                // If error, try again in 5 minutes
                setTimeout(updateLiveHoursDisplay, 300000);
            });
        }

        // Function to update the date range
        function updateDateRange() {
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            loadData(startDate, endDate);
        }

        // Function to load departments and populate filter dropdown
        function loadDepartments(employees) {
            const departmentFilter = document.getElementById('departmentFilter');
            
            // Clear existing options except "All Departments"
            while (departmentFilter.options.length > 1) {
                departmentFilter.remove(1);
            }
            
            // Get unique departments
            const departments = [...new Set(employees.map(employee => employee.department))];
            
            // Add department options
            departments.forEach(department => {
                const option = document.createElement('option');
                option.value = department;
                option.textContent = department;
                departmentFilter.appendChild(option);
            });
        }

        // Function to filter employees by department
        function filterByDepartment() {
            const department = document.getElementById('departmentFilter').value;
            const employeeContainers = document.querySelectorAll('.employee-container');
            
            employeeContainers.forEach(container => {
                if (department === 'all' || container.dataset.department === department) {
                    container.style.display = 'block';
                } else {
                    container.style.display = 'none';
                }
            });
        }

        // Function to load data for a specific date range
        function loadData(startDate, endDate) {
            Promise.all([fetchEmployees, fetchClockingData])
                .then(([employees, clockingData]) => {
                    const container = document.getElementById('employeeTimeline');
                    const dateRange = document.getElementById('dateRange');
                    const totalEmployees = document.getElementById('totalEmployees');

                    // Load departments for filter
                    loadDepartments(employees);

                    // Filter clocking data for the selected date range
                    const filteredClockingData = clockingData.filter(entry => {
                        const entryDate = new Date(entry.timestamp).toISOString().split('T')[0];
                        return entryDate >= startDate && entryDate <= endDate;
                    });

                    // Set report header information
                    dateRange.textContent = `${startDate} to ${endDate}`;
                    totalEmployees.textContent = employees.length;

                    // Create a map of employees for quick lookup by ID
                    const employeeMap = new Map();
                    employees.forEach(employee => {
                        employeeMap.set(employee.id, employee);
                    });

                    // Group clocking data by employee and by day
                    const employeeClockingMap = new Map();
                    filteredClockingData.forEach(entry => {
                        if (!employeeClockingMap.has(entry.employeeId)) {
                            employeeClockingMap.set(entry.employeeId, {});
                        }
                        const date = new Date(entry.timestamp).toISOString().split('T')[0];
                        if (!employeeClockingMap.get(entry.employeeId)[date]) {
                            employeeClockingMap.get(entry.employeeId)[date] = [];
                        }
                        employeeClockingMap.get(entry.employeeId)[date].push(entry);
                    });

                    // Clear existing content
                    container.innerHTML = '';

                    // Display timeline for each employee
                    employeeClockingMap.forEach((days, employeeId) => {
                        const employee = employeeMap.get(employeeId);
                        if (employee) {
                            // Create employee container
                            const employeeDiv = document.createElement('div');
                            employeeDiv.className = 'employee-container';
                            employeeDiv.id = `employee-${employeeId}`;
                            employeeDiv.dataset.department = employee.department;

                            // Add employee header
                            const header = document.createElement('div');
                            header.className = 'employee-header';
                            header.textContent = `${employee.name} (${employee.department})`;
                            employeeDiv.appendChild(header);

                            // Initialize total hours worked for the employee
                            let employeeTotalHours = 0;

                            // Add timeline for each day
                            Object.entries(days).forEach(([date, entries]) => {
                                const dayDiv = document.createElement('div');
                                dayDiv.className = 'day-container';

                                // Add day header
                                const dayHeader = document.createElement('div');
                                dayHeader.className = 'day-header';
                                dayHeader.textContent = `Date: ${new Date(date).toLocaleDateString('en-US', { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' })}`;
                                dayDiv.appendChild(dayHeader);

                                // Add timeline scale
                                const timelineScale = document.createElement('div');
                                timelineScale.className = 'timeline-scale';
                                for (let hour = 7; hour <= 19; hour += 2) {
                                    const timeLabel = document.createElement('span');
                                    timeLabel.textContent = `${hour}:00`;
                                    timelineScale.appendChild(timeLabel);
                                }
                                dayDiv.appendChild(timelineScale);

                                // Add timeline
                                const timeline = document.createElement('div');
                                timeline.className = 'timeline';

                                // Sort entries by timestamp
                                entries.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                                // Define the start and end of the workday (7:00 AM to 7:00 PM)
                                const workdayStart = new Date(`${date}T07:00:00Z`);
                                const workdayEnd = new Date(`${date}T19:00:00Z`);
                                const totalDuration = workdayEnd - workdayStart;

                                // Add hourly markers
                                for (let hour = 7; hour <= 19; hour++) {
                                    const markerTime = new Date(`${date}T${String(hour).padStart(2, '0')}:00:00Z`);
                                    const markerPosition = ((markerTime - workdayStart) / totalDuration) * 100;

                                    // Create marker element
                                    const marker = document.createElement('div');
                                    marker.className = 'marker';
                                    marker.style.left = `${markerPosition}%`;

                                    // Add label for the hour
                                    const markerLabel = document.createElement('div');
                                    markerLabel.className = 'marker-label';
                                    markerLabel.textContent = `${hour}:00`;
                                    marker.appendChild(markerLabel);

                                    timeline.appendChild(marker);
                                }

                                // Add the "no clockings" segment before the first clock-in
                                const firstEvent = new Date(entries[0].timestamp);
                                const noClockingsBefore = firstEvent - workdayStart;
                                if (noClockingsBefore > 0) {
                                    const noClockingsSegment = document.createElement('div');
                                    noClockingsSegment.className = 'progress-bar clocked-out';
                                    noClockingsSegment.style.width = `${(noClockingsBefore / totalDuration) * 100}%`;
                                    noClockingsSegment.style.left = '0%';
                                    timeline.appendChild(noClockingsSegment);
                                }

                                // Track break and lunch periods for violation checking
                                let breakStartTime = null;
                                let lunchStartTime = null;
                                
                                // Create progress bar segments for clockings
                                let previousTime = firstEvent;
                                let currentState = 'clocked-out'; // Default state
                                
                                // If first event is Clock In, set state to working
                                if (entries[0].type === 'Clock In') {
                                    currentState = 'working';
                                }

                                // Process all entries
                                for (let i = 0; i < entries.length; i++) {
                                    const entry = entries[i];
                                    const eventTime = new Date(entry.timestamp);
                                    const segmentDuration = eventTime - previousTime;
                                    
                                    // Skip creating a segment if there's no duration
                                    if (segmentDuration <= 0) {
                                        // Update state based on the event type
                                        if (entry.type === 'Clock In') {
                                            currentState = 'working';
                                        } else if (entry.type === 'Break Start') {
                                            currentState = 'break';
                                            breakStartTime = eventTime;
                                        } else if (entry.type === 'Break End') {
                                            currentState = 'working';
                                        } else if (entry.type === 'Lunch Start') {
                                            currentState = 'lunch';
                                            lunchStartTime = eventTime;
                                        } else if (entry.type === 'Lunch End') {
                                            currentState = 'working';
                                        } else if (entry.type === 'Clock Out') {
                                            currentState = 'clocked-out';
                                        }
                                        
                                        previousTime = eventTime;
                                        continue;
                                    }

                                    // Create segment with current state
                                    const segment = document.createElement('div');
                                    segment.className = `progress-bar ${currentState}`;
                                    segment.style.width = `${(segmentDuration / totalDuration) * 100}%`;
                                    segment.style.left = `${((previousTime - workdayStart) / totalDuration) * 100}%`;
                                    timeline.appendChild(segment);
                                    
                                    // Check for break violations (if applicable)
                                    if (currentState === 'break' && entry.type === 'Break End') {
                                        const breakDuration = eventTime - breakStartTime;
                                        const breakMinutes = breakDuration / (1000 * 60);
                                        
                                        // If break is longer than 15 minutes, mark as violation
                                        if (breakMinutes > 15) {
                                            const violationStart = new Date(breakStartTime.getTime() + (15 * 60 * 1000));
                                            const violationDuration = eventTime - violationStart;
                                            const violationWidth = (violationDuration / totalDuration) * 100;
                                            const violationLeft = ((violationStart - workdayStart) / totalDuration) * 100;
                                            
                                            const violationMarker = document.createElement('div');
                                            violationMarker.className = 'break-violation';
                                            violationMarker.style.width = `${violationWidth}%`;
                                            violationMarker.style.left = `${violationLeft}%`;
                                            
                                            const tooltip = document.createElement('div');
                                            tooltip.className = 'tooltip';
                                            tooltip.textContent = `Break violation: ${Math.round(breakMinutes)} min (15 min limit)`;
                                            violationMarker.appendChild(tooltip);
                                            
                                            timeline.appendChild(violationMarker);
                                        }
                                    }
                                    
                                    // Check for lunch violations (if applicable)
                                    if (currentState === 'lunch' && entry.type === 'Lunch End') {
                                        const lunchDuration = eventTime - lunchStartTime;
                                        const lunchMinutes = lunchDuration / (1000 * 60);
                                        
                                        // If lunch is longer than 30 minutes, mark as violation
                                        if (lunchMinutes > 30) {
                                            const violationStart = new Date(lunchStartTime.getTime() + (30 * 60 * 1000));
                                            const violationDuration = eventTime - violationStart;
                                            const violationWidth = (violationDuration / totalDuration) * 100;
                                            const violationLeft = ((violationStart - workdayStart) / totalDuration) * 100;
                                            
                                            const violationMarker = document.createElement('div');
                                            violationMarker.className = 'break-violation';
                                            violationMarker.style.width = `${violationWidth}%`;
                                            violationMarker.style.left = `${violationLeft}%`;
                                            
                                            const tooltip = document.createElement('div');
                                            tooltip.className = 'tooltip';
                                            tooltip.textContent = `Lunch violation: ${Math.round(lunchMinutes)} min (30 min limit)`;
                                            violationMarker.appendChild(tooltip);
                                            
                                            timeline.appendChild(violationMarker);
                                        }
                                    }

                                    // Update state for the next segment
                                    if (entry.type === 'Clock In') {
                                        currentState = 'working';
                                    } else if (entry.type === 'Break Start') {
                                        currentState = 'break';
                                        breakStartTime = eventTime;
                                    } else if (entry.type === 'Break End') {
                                        currentState = 'working';
                                    } else if (entry.type === 'Lunch Start') {
                                        currentState = 'lunch';
                                        lunchStartTime = eventTime;
                                    } else if (entry.type === 'Lunch End') {
                                        currentState = 'working';
                                    } else if (entry.type === 'Clock Out') {
                                        currentState = 'clocked-out';
                                    }
                                    
                                    previousTime = eventTime;
                                }

                                // Add the "no clockings" segment after the last clock-out
                                const lastEvent = new Date(entries[entries.length - 1].timestamp);
                                const noClockingsAfter = workdayEnd - lastEvent;
                                if (noClockingsAfter > 0) {
                                    const noClockingsSegment = document.createElement('div');
                                    // Use clocked-out style for the remaining time if the last event was a Clock Out
                                    // Otherwise, use the current state
                                    const lastEventType = entries[entries.length - 1].type;
                                    const finalState = lastEventType === 'Clock Out' ? 'clocked-out' : currentState;
                                    noClockingsSegment.className = `progress-bar ${finalState}`;
                                    noClockingsSegment.style.width = `${(noClockingsAfter / totalDuration) * 100}%`;
                                    noClockingsSegment.style.left = `${((lastEvent - workdayStart) / totalDuration) * 100}%`;
                                    timeline.appendChild(noClockingsSegment);
                                }

                                dayDiv.appendChild(timeline);

                                // Add notes (if any)
                                const notes = document.createElement('div');
                                notes.className = 'notes';
                                notes.textContent = 'Notes: [Add notes here]';
                                dayDiv.appendChild(notes);

// Calculate total hours worked for the day
const totalHours = calculateTotalHours(entries);
const totalHoursDiv = document.createElement('div');
totalHoursDiv.className = 'total-hours';

// Check if the day is today
const isToday = new Date(date).toDateString() === new Date().toDateString();
if (isToday) {
    // For today, only show the live hours counter with "Clocked in:" text
    totalHoursDiv.innerHTML = `
        <div class="hours-container">
            <div class="live-hours">
                <strong>Clocked in:</strong> <span id="live-hours-${employeeId}" class="live-time-counter">Calculating...</span>
                <span class="live-indicator">●</span>
            </div>
        </div>
    `;
} else {
    // Regular display for past days
    totalHoursDiv.textContent = `Total Hours Worked: ${totalHours.toFixed(2)} hours`;
}
dayDiv.appendChild(totalHoursDiv);

                                // Add to employee's total hours
                                employeeTotalHours += totalHours;

                                employeeDiv.appendChild(dayDiv);
                            });

                            // Add total hours worked for the employee
                            const employeeTotalHoursDiv = document.createElement('div');
                            employeeTotalHoursDiv.className = 'employee-total-hours';
                            employeeTotalHoursDiv.textContent = `Total Hours Worked (All Days): ${employeeTotalHours.toFixed(2)} hours`;
                            employeeDiv.appendChild(employeeTotalHoursDiv);

                            container.appendChild(employeeDiv);
                        }
                    });

                    // Apply initial department filter
                    filterByDepartment();

                    // Start the live hours update for today
                    if (document.querySelector('.live-time-counter')) {
                        updateLiveHoursDisplay();
                    }

                    // Animate progress bars with a slight delay to ensure proper rendering
                    setTimeout(() => {
                        document.querySelectorAll('.progress-bar').forEach(bar => {
                            const originalWidth = bar.style.width;
                            bar.style.width = '0';
                            
                            // Force a reflow to ensure the animation works
                            void bar.offsetWidth;
                            
                            // Set back to original width to trigger animation
                            bar.style.width = originalWidth;
                        });
                    }, 300);
                })
                .catch(error => console.error('Error fetching data:', error));
        }

        // Function to calculate total hours worked
        function calculateTotalHours(entries) {
            let totalMilliseconds = 0;
            let clockInTime = null;

            entries.forEach(entry => {
                if (entry.type === 'Clock In') {
                    clockInTime = new Date(entry.timestamp);
                } else if (entry.type === 'Clock Out' && clockInTime) {
                    const clockOutTime = new Date(entry.timestamp);
                    totalMilliseconds += clockOutTime - clockInTime;
                    clockInTime = null;
                }
            });

            return totalMilliseconds / (1000 * 60 * 60);
        }

        // Function to toggle employee status visibility
        function toggleEmployeeStatus() {
            const employeeStatusGrid = document.getElementById('employeeStatusGrid');
            if (employeeStatusGrid.style.display === 'none') {
                showEmployeeStatus();
                employeeStatusGrid.style.display = 'grid';
            } else {
                employeeStatusGrid.style.display = 'none';
            }
        }

        // Function to show employee status
        function showEmployeeStatus() {
            const employeeStatusGrid = document.getElementById('employeeStatusGrid');
            employeeStatusGrid.innerHTML = ''; // Clear previous content

            // Get today's date in YYYY-MM-DD format
            const today = new Date().toISOString().split('T')[0];

            // Fetch both employees and clocking data
            Promise.all([
                fetch('https://raw.githubusercontent.com/SCOSeanKly/TimeKeeperReports/main/TimeKeeperEmployees.json'),
                fetch('https://raw.githubusercontent.com/SCOSeanKly/TimeKeeperReports/main/timekeeper_entries.json')
            ])
            .then(responses => Promise.all(responses.map(response => response.json())))
            .then(([employees, clockingData]) => {
                // Filter entries for today
                const todayEntries = clockingData.filter(entry => {
                    const entryDate = new Date(entry.timestamp).toISOString().split('T')[0];
                    return entryDate === today;
                });

                // Group entries by employee
                const employeeStatusMap = new Map();
                todayEntries.forEach(entry => {
                    if (!employeeStatusMap.has(entry.employeeId)) {
                        employeeStatusMap.set(entry.employeeId, []);
                    }
                    employeeStatusMap.get(entry.employeeId).push(entry);
                });

                // Create a card for every employee - even those without entries today
                employees.forEach(employee => {
                    // Check if employee has entries today
                    const entries = employeeStatusMap.get(employee.id) || [];
                    
                    // Determine status based on entries
                    let statusClass = 'clocked-out'; // Default status
                    let statusText = 'Not Clocked In';
                    let clockInTimeText = 'No clock-in today';
                    
                    if (entries.length > 0) {
                        // Sort entries by timestamp
                        entries.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                        
                        // Get the latest entry to determine current status
                        const latestEntry = entries[entries.length - 1];
                        
                        // Update clock-in time text
                        clockInTimeText = `Clocked In: ${new Date(entries[0].timestamp).toLocaleTimeString()}`;
                        
                        // Determine the status class based on the latest entry type
                        if (latestEntry.type === 'Clock In') {
                            statusClass = 'clocked-in';
                            statusText = 'Working';
                        } else if (latestEntry.type === 'Break Start') {
                            statusClass = 'on-break';
                            statusText = 'On Break';
                        } else if (latestEntry.type === 'Lunch Start') {
                            statusClass = 'on-lunch';
                            statusText = 'On Lunch';
                        } else if (latestEntry.type === 'Break End' || latestEntry.type === 'Lunch End') {
                            statusClass = 'clocked-in'; // After break/lunch end, employee is clocked in
                            statusText = 'Working';
                        } else if (latestEntry.type === 'Clock Out') {
                            statusClass = 'clocked-out';
                            statusText = 'Clocked Out';
                        }
                    }
                    
                    // Create employee status card
                    const card = document.createElement('div');
                    card.className = `employee-status-card ${statusClass}`;
                    
                    // Set inline styles for text color as a fallback method
                    // This ensures the text is visible even if CSS rules conflict
                    const textColor = (statusClass === 'on-break') ? 'black' : 'white';
                    
                    card.onclick = () => {
                        const employeeElement = document.getElementById(`employee-${employee.id}`);
                        if (employeeElement) {
                            employeeElement.scrollIntoView({ behavior: 'smooth' });
                        } else {
                            alert(`No timeline data available for ${employee.name} in the selected date range`);
                        }
                    };
                    
                    // Add employee name with inline styles
                    const name = document.createElement('h3');
                    name.textContent = employee.name;
                    name.style.color = textColor;
                    card.appendChild(name);
                    
                    // Add department with inline styles
                    const department = document.createElement('p');
                    department.textContent = `Department: ${employee.department}`;
                    department.style.color = textColor;
                    card.appendChild(department);
                    
                    // Add clock-in time with inline styles
                    const clockInTime = document.createElement('p');
                    clockInTime.textContent = clockInTimeText;
                    clockInTime.style.color = textColor;
                    card.appendChild(clockInTime);
                    
                    // Add current status with inline styles
                    const status = document.createElement('p');
                    status.textContent = `Status: ${statusText}`;
                    status.style.color = textColor;
                    card.appendChild(status);
                    
                    employeeStatusGrid.appendChild(card);
                });
                
                // Add inline style to ensure background colors aren't overridden
                document.querySelectorAll('.employee-status-card.clocked-out').forEach(card => {
                    card.style.backgroundColor = '#333';
                });
                document.querySelectorAll('.employee-status-card.clocked-in').forEach(card => {
                    card.style.backgroundColor = '#4CAF50';
                });
                document.querySelectorAll('.employee-status-card.on-break').forEach(card => {
                    card.style.backgroundColor = '#FFC107';
                });
                document.querySelectorAll('.employee-status-card.on-lunch').forEach(card => {
                    card.style.backgroundColor = '#FF9800';
                });
            })
            .catch(error => {
                console.error('Error fetching data:', error);
                employeeStatusGrid.innerHTML = '<p>Error loading employee status data</p>';
            });
        }

        // Function to print the report
        function printReport() {
            window.print();
        }

        // Load data for the default date range
        loadData(lastMonday.toISOString().split('T')[0], lastSunday.toISOString().split('T')[0]);
    </script>
</body>
</html>